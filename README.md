# DSA_Problem_Solving_Part2
This is second directory because github reached limit of no of files for first repo "DSA_Problem_Solving"

388. Arranging Coins => this is classic binary search problem
389. Remove Duplicate Letters => using stack,track of last idx and its visited status lot of things are involved here
390. Teemo Attacking => simple linear time observation based problem
391. Maximum Frequency Stack => this is one of the best problem with stack of stack approach I solved
392. Relative Ranks => clubbing elements and indices then sort them by elemets and prepare answer
393. Longest Uncommon Subsequence I => kinda brainteaser problem with only observations.
394. Reverse String II => just reverse then windows and go ahead
395. Array Partition I => this is also observation based easy problem
396. Binary Tree Tilt => simple postorder problem
397. Longest Harmonious Subsequence => simple hashmap and sorting problem
398. Construct String from Binary Tree => little ambiguous problem but simple preorder traversal will solve the issue
399. Robot Return to Origin => very simple problem 
400. Second Minimum Node In a Binary Tree => little tricky but did in brute force way
401. Longest Continuous Increasing Subsequence => this is very simple sliding winow problem
402. Minimum Domino Rotations For Equal Row => this is very good observation based problem
403. Remove All Adjacent Duplicates In String => classic stack problem same as balanced parenthesis
404. Remove All Adjacent Duplicates in String II => this is another advanced problem on the top of this.
405. Sort stack using another stack(sp - gfg) => very simple problem
406. Smallest String With A Given Numeric Value => this is classic Observation based problem VVIMP
407. Previous smaller element, Next Greater Element => very simple problem using stack
408. Broken Calculator => this is reverse thinking problem 
409. Maximal Rectangle => using largest historgram problem we can solve this
410. MAX and MIN(sp) => sum of (max - min) of all subarrays of array VERy good problem can be solved using contributions and NGE,NSE,PGE,PSE
411. Boats to Save People => very simple sorting and two pointer problem
412. Binary Number with Alternating Bits => get prev and current bit and compare
413. Two City Scheduling => totally observation based problem..
414. N integers containing only 1, 2 & 3(sp - leetcode[Numbers At Most N Given Digit Set]) => this is classic queue problem
415. Perfect Numbers - Find Nth even length palindromic number formed using digits X and Y(sp - gfg) => this also is classic queue problem
416. Reversing Elements Of Queue(sp -gfg) +> this can be done using 3 steps
417. Valid Palindrome II => this is greedy problem with two edge cases
418. Sum of min and max(sp - gfg) => this problem is extension of sliding window maximum and minimum and their addition
419. Search in Rotated Sorted Array II=> same problem with duplicate edge case move both ptrs if values are same
420. N-ary Tree Preorder Traversal => very simple problem
421. N-ary Tree Postorder Traversal => this is also very simple problem
422. N-ary Tree Level Order Traversal => very simple problem using deque
423. Maximum Depth of N-ary Tree => did using level order traversal
424. Queue based approach for first non-repeating character in a stream(sp - gfg) => good question combination of queue and hashmap
425. Infix to Postfix(sp - gfg) => this is very simple problem with some thought process and edge cases
426. Shortest Distance to a Character => linear time and linear space by using two extraa arrays for precomputation
427. Nodes Count(sp) => simple problem
428. Nodes Sum(sp) => total nodes sum
429. Tree Height(sp) => height of tree (leaf node height is 0)
430. Nodes Max(sp) => finding max ele in binary tree
431. Difference between sums of odd level and even level nodes of a Binary Tree(sp - gfg) => simple level order problem
432. Same Tree => very simple problem
433. Depth of each node(sp) => did in java using preorder
434. Rectangle Overlap => this is very simple observation based problem
435.  Binary Tree Right Side View => simple level order problem 
436.  Binary Tree Level Order Traversal II => using list or deque and level order traversal
437. Construct Binary Tree from Preorder and Inorder Traversal => very good problem
438. Construct Binary Tree from Inorder and Postorder Traversal => very good problem just reverse of above problem
439. Check if a given Binary Tree is SumTree(sp - gfg) => kahin pe tir kahin pe nishana need traversal to get sum of tree if any root.val != childern sum then set false
440. Binary Tree Zigzag Level Order Traversal => very imp level order and deque problem
441. Lowest Common Ancestor in a Binary Tree(sp - gfg) => USIng values we have to find the path of both nodes then find lca
442. Delete Node in a BST => this is very important problem
443. Validate Binary Search Tree => very simple and important problem
444. Convert Sorted Array to Binary Search Tree => find the mid make it root then recur for left and right
445. Floor and Ceil in BST(sp - gfg) => finding floor and ceil in bst is very easy
446. BST nodes in a range(sp - gfg) => first locate node in range then recur for left and right subtree
447. Transpose Matrix => very easy implementation based problem
448. Leaf-Similar Trees => using queue and preorder traversal
449. 3Sum With Multiplicity => coupple of things are combined
450. Kth Smallest Element in a BST => very simple problem using inorder
451. Shortest distance between two nodes in BST(sp - gfg) => first locate the ancestor then calculate edges
452. Last Stone Weight => this is very easy maxHeap problem
453. Word Search => this is very beautiful backtracking and dfs problem asked in startup from mumbai
454. Binary tree to Circular Doubly Linked List (BST to DLL) => convert left and right subtree to dll then merge root and both dll and for second question convert to CDLL and at last break the link
455. Diameter of Binary Tree => very good problem use get height function to track diameter
456. Boundary of Binary Tree => this is very good problem
457. Binary Tree Maximum Path Sum => This is very GOOD problem of postorder traversal kahin pe nigahen kahin pe nishana
458. Difference between sums of odd level and even level nodes of a Binary Tree(sp - gfg) => simple level order problem
459. Serialize and Deserialize Binary Tree => this is very good level order traversal problem
460. Game of Life => this is very simple placeholder problem
461. Coin Change 2 => this is very good dp problem
462. Equal Tree Partition => this is classic of kahin pe nigahein kahin pe nishana using postorder to calculate sum then check if half is present into set or not
463. Trim a Binary Search Tree => we can use bst props and skip the subtrees
464. Is Word present in dictionary(sp) => this is classsic trie problem
465. Find shortest unique prefix for every word in a given list(sp - gfg) => this can be easily solved using trie
466. Contacts(sp - hackerrank) => this is also classic trie problem along with pf count
467. Increasing Order Search Tree => very simple tree problem
468. Magician and Chocolates => this is very good problem of maxheap
469. Connect n ropes with minimum cost => this is simple minheap problem
470. Find K Closest Points to the Origin => this is very easy maxHeap problem
471. Kth Smallest Element in a Sorted Matrix => solved using min heap
472. Max Continuous Series of 1s => this is very good sliding window problem
473. Recover Binary Search Tree => this problem is related to finding discrepancies among the inorder
474. Distribute Candies to People => this is simulation based problem
475. Element Appearing More Than 25% In Sorted Array => simple two pointers problem
476. Number of Equivalent Domino Pairs => simple hashtable problem to count pairs
477. N-th Tribonacci Number => this is simple dp problem
478. Rank Transform of an Array => sorting and simulation will solve this problem
479. Candy => this is very good greedy problem 
480. Activity Selection Problem(sp - gfg) => this is sorting greedy problem
481. Smallest String With Swaps => this is connected component,dfs and sorting problem
482. Is Graph Bipartite? => this is simple bfs problem
483. Distance Between Bus Stops => clockwise and anticlockwise logic for anticlockwise cover last ele then first elements..
484. Reverse Integer => main thing is to check if no is in range of 32 bit ..
485. Multiply Strings => use same function to convert string to int then multiply it and make it string
486. Backspace String Compare => think backwards..
487. Repeated DNA Sequences => this is simple sliding window and hashmap problem
488. Sort Array By Parity => this can be solved using dutch national flag algo..
489. Shortest Unsorted Continuous Subarray => this can be solved using NSE and PGE..
490. Perfect Squares => this is very good dp problem..
491. Max Number of K-Sum Pairs => this is just counting of two sum pairs..






